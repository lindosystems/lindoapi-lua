-- Final version of lsgen_lingo_to_vba.lua

local lapp = require 'pl.lapp'

local args = lapp [[
    Lingo Model to VBA Translator
    -m,--model (string)  Lingo model file to process
    -o,--output (default "output.bas")  Output VBA file
]]

-- Utility: trim spaces
local function trim(s)
    return (s:gsub("^%s+", ""):gsub("%s+$", ""))
end

-- Read whole model into lines
local file = assert(io.open(args.model, "r"))
local lines = {}
for line in file:lines() do
    table.insert(lines, trim(line))
end
file:close()

-- Combine multi-line constraints into single line statements
local blocks = {}
local current = ""
for _, line in ipairs(lines) do
    if line ~= '' then
        current = current .. ' ' .. line
        if current:find(';') then
            current = current:gsub(';', '')
            table.insert(blocks, trim(current))
            current = ""
        end
    end
end

-- Build variable map v{} for indexing
local varlist = {}
local vmap = {}
for _, block in ipairs(blocks) do
    for var in block:gmatch("X%d+") do
        if not vmap[var] then
            table.insert(varlist, var)
            vmap[var] = #varlist
        end
    end
end

-- Helper: convert Lingo expression to VBA
local function convert_expr(expr)
    -- Replace operators
    expr = expr:gsub("@SQRT%(", "Sqr(")
    expr = expr:gsub("@SIN%(", "Sin(")
    expr = expr:gsub("@COS%(", "Cos(")
    expr = expr:gsub("@TAN%(", "Tan(")
    expr = expr:gsub("@EXP%(", "Exp(")
    expr = expr:gsub("@LOG%(", "Log(")

    -- Replace variables Xnnn -> val.Cells(idx, 1).Value
    expr = expr:gsub("X(%d+)", function(var)
        var = 'X' .. var
        if vmap[var] then
            return "CDbl(val.Cells(" .. vmap[var] .. ", 1).Value)"
        else
            return "**UNKNOWNVAR**"
        end
    end)

    return expr
end

-- Generate VBA output
local output = {}

-- Insert header
output[#output+1] = "' Generated by lsgen_lingo_to_vba.lua"
output[#output+1] = "Option Explicit"
output[#output+1] = ""

-- Generate variable extraction code
local function vba_header()
    local lines = {}
    lines[#lines+1] = "    Dim i As Integer"
    lines[#lines+1] = "    Dim v(1 To "..#varlist..") As Double"
    lines[#lines+1] = "    For i = 1 To "..#varlist
    lines[#lines+1] = "        v(i) = CDbl(val.Cells(i, 1).Value)"
    lines[#lines+1] = "    Next i"
    return table.concat(lines, "\n")
end

for _, block in ipairs(blocks) do
    local name, expr = block:match("%[(.-)%]%s*(.+)")
    if name and expr then
        local funcname = ""
        if expr:match("^MIN%s*=") or expr:match("^MAX%s*=") then
            funcname = "Objective_" .. name
            expr = expr:gsub("^%s*MIN%s*=", ""):gsub("^%s*MAX%s*=", "")
        else
            funcname = "Constraint_" .. name
        end
        expr = convert_expr(expr)

        output[#output+1] = "Function " .. funcname .. "(val As Range) As Double"
        output[#output+1] = vba_header()
        output[#output+1] = "    " .. funcname .. " = " .. expr
        output[#output+1] = "End Function\n"
    end
end

-- Also generate list of variables
output[#output+1] = "' Variable listing:"
for idx, var in ipairs(varlist) do
    output[#output+1] = "'   "..idx..": "..var
end

-- Save output
local fout = assert(io.open(args.output, "w"))
fout:write(table.concat(output, "\n"))
fout:close()

print("Written VBA module to " .. args.output)
